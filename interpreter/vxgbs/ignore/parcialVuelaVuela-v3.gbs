type TorreDeControl is record {
	field vs
	field ps	
}

type Vuelo is record {
	field numero
	field origen
	field destino
	field estado
	field etapaEnPlanDeVuelo
}

type PlanDestino is record {
	field origen
	field destino
	field planDeVuelo
}

type Coord is record {
	field x
	field y
}

#mkCoord
function crd(x,y) {
    return(Coord(x <- x, y <- y))
}

function eqCoord(c1, c2) {
	return(x(c1) == x(c2) && y(c1) == y(c2))
}



##################################
#		Ejercicio 1												  #
##################################

function hallarVuelo(vs, estadov) {
	rec := vs
	while (not estado(head(rec)) == estadov) {
		rec := tail(rec)
	}
	return(head(rec))
}



##################################
#		Ejercicio 2												  #
##################################

function listoParaDespegar() { return(1) }
function enVuelo() { return(2) }
function aterrizado() { return(3) }


function cambiarEstado(v, e) {
    v2 := v
    v2.estado := e
    return(v2)
}

function aterrizar(vuelo') {
	return(cambiarEstado(vuelo', aterrizado()))
}

function despegarVuelo(vuelo') {
v := cambiarEstado(vuelo', enVuelo())
v.etapaEnPlanDeVuelo := 1
return(v)
}

function actualizarVuelos(vst) {
	t2 := t
	t2.vs := vst        
	return(t2)
}

function eliminarVuelo(vs, numVuelo) {
	rec := vs
	nuevoVs := []
	while (not numVuelo == numero(head(rec))) { 
		nuevoVs := nuevoVs ++ [head(rec)]
		rec := tail(rec)
	}
	return(nuevoVs ++ tail(rec))
}

function actualizarVuelo(v) {
	return(actualizarVuelos(eliminarVuelo(vs(), numero(v)) ++ [v]))
}

function despegarUnVuelo() {
	vueloListo := hallarVuelo(vs(), listoParaDespegar())
	vueloDespega := despegarVuelo(vueloListo)
	return(actualizarVuelo(vueloDespega))
}



##################################
#		Ejercicio 3												  #
##################################

function length(xs) {
	rec := xs
	l := 0
	while (not isNil(rec)) {
		l := l + 1
		rec := tail(rec)
	}
	return(l)
} 

function planDestinoCorresponde(p, v) {
	return(eqCoord(origen(p), origen(v)) && eqCoord(destino(p), destino(v)))
}

function planDeVueloPara(v) {
	rec := ps
	while (not planDestinoCorresponde(head(rec), v)) {
		rec := tail(rec)
	}
	return(planDeVuelo(head(rec)))
}

function cumplioPlanDeVuelo(v) {
	return(length(planDeVueloPara(v)) == etapaEnPlanDeVuelo(v))
}

function debeAterrizar(v) {
	return(estado(v) == enVuelo() && cumplioPlanDeVuelo(v))
}

function hallarVueloAAterrizar() {
	rec := vs()
	while (not debeAterrizar(head(rec))) {
		rec := tail(rec)
	}
	return(head(rec))
}

function aterrizarVuelo() {
	return(actualizarVuelo(aterrizar(hallarVueloAAterrizar())))
}



##################################
#		Ejercicio 4												  #
##################################

function sumarCoord(c1, c2) {
	return(Coord(x <- x(c1) + x(c2), y <- y(c1) + y(c2)))
}

function mkCoord(x', y') {
	return(Coord(x <- x', y <- y'))
}

function dirACoord(d) {
	crd := mkCoord(0, 0)
	switch (d) to
		Este -> {crd :=  mkCoord(1, 0)}
		Oeste -> {crd := mkCoord(-1, 0)}
		Norte -> {crd := mkCoord(0, 1)}
		_ -> {crd := mkCoord(0, -1)}
	return(crd)
}

function simularNEtapas(v, n) {
	crd := origen(v)
	pv := planDeVueloPara(v)
	i := 0
	while (i < n) {
		crd := sumarCoord(crd, dirACoord(head(pv)))	
		i := i + 1
	}
	return(crd)
}

function coordenadaEnEtapa_i(v, i) {
	return(simularNEtapas(v, etapaEnPlanDeVuelo(v) + i))
}



##################################
#		Ejercicio 5												  #
##################################

function estaVolandoEnEtapa_i(v, i) {
	return(length(planDeVueloPara(v)) <= i)
}

function coordsEnEtapa_i(i) {
	rec := vs()
	crds := []
	while (not isNil(rec)) {
		if (estaVolandoEnEtapa_i(head(rec), i)) {
			crds := crds ++ [coordenadaEnEtapa_i(head(rec), i)]
		}
		rec := tail(rec)
	}
	return(crds)
}

function incluidoCoord(crd, crds) {
	rec := crds
	while (not isNil(rec) && not eqCoord(crd, head(rec))) {
		rec := tail(rec)
	}
	return(not isNil(rec))
}

function coordRepetida(crds) {
	e := head(crds)
	rec := tail(crds)
	repetida := False
	while (not isNil(rec) && not repetida) {
		repetida := incluidoCoord(e, rec)
		e := head(rec)
		rec := tail(rec)
	}
	return(repetida)
}

function hayColisionEnEtapa_i(i) {
	return(coordRepetida(coordsEnEtapa_i(i)))	
}



##################################
#		Ejercicio 6												  #
##################################

function len(xs) {
    c := 0
    foreach x in xs {
        c := c + 1
    }
    return(c)
}

function mapLongitudes(xss) {
    ls := []
    foreach xs in xss {
        ls := ls ++ [len(xs)]
    }
    return(ls)
}

function maximaLongitudPlanDeVuelo() {
    ls := mapLongitudes(vs)
    max := head(ls)
    foreach l in ls {
        if (l > max) {
            max := l
        }
    }
    return(max)
}

function hayColision() {
	n := maximaLongitudPlanDeVuelo()
	colisionan := False
	while (n > 0 && not colisionan) {
		colisionan := hayColisionEnEtapa_i(n)
		n := n - 1
	}
	return(colisionan)
}



##################################
#		Ejercicio 7												  #
##################################

procedure IrAlOrigen() {
    IrAlBorde(Oeste)
    IrAlBorde(Sur)
}

function medirHacia(d) {
    t2 := t
    pasos := 0
    while(puedeMover(t2, d)) {
        t2.Mover(d)
        pasos := pasos + 1
    }
    return(pasos)
}

procedure MoverN(d, n) {
    repeat n {
        Mover(d)
    }
}

procedure IrACoord(crd) {
    IrAlOrigen()
    MoverN(Este, x(crd))
    MoverN(Norte, y(crd))
}

function coordAct() {
    return(Coord(x <- medirHacia(Oeste),
                 y <- medirHacia(Sur)))
}

procedure PonerN(c, n) {
    repeat n { Poner(c) }
}

procedure PonerEnCoord(crd, c) {
    coordAct := coordAct()
    IrACoord(crd)
	Poner(c)
    IrACoord(coordAct)
}

procedure PonerNEnCoord(crd, c, n) {
    coordAct := coordAct()
    IrACoord(crd)
	PonerN(c, n)
    IrACoord(coordAct)
}

function hayBolitasEnCoord(c, crd) {
	trec := t
	trec.IrACoord(crd)
	return(hayBolitas(c))
}

function colorOrigen() { return(Azul) }
function colorDestino() { return(Negro) }
function colorVuelo() { return(Verde) }

procedure PonerEnCoordSiNoHay(crd, c) {
	if (not hayBolitasEnCoord(c, crd)) {
		PonerEnCoord(crd, c)
	}
}

function coordActualVuelo(tc, v) {
	return(simularNEtapas(tc, v, etapaEnPlanDeVuelo(v)))
}

procedure DibujarVueloEnEtapaActual(tc, v) {
	PonerNEnCoord(coordActualVuelo(tc, v), colorVuelo(), numero(v))
}

procedure DibujarVuelo(tc, v) {
	PonerEnCoordSiNoHay(origen(v), colorOrigen())
	PonerEnCoordSiNoHay(destino(v), colorDestino())
	DibujarVueloEnEtapaActual(tc, v)
}

procedure Radar(tc) {
	rec := vs(tc)
	while (not isNil(rec)) {
		DibujarVuelo(tc, head(rec))
		rec := tail(rec)
	}	
}

"""
    InicializaciÃ³n de Torre de control
"""

function mkPlanDestino(origen, destino, planDeVuelo) {
    return(PlanDestino(origen <- origen, destino <- destino, planDeVuelo <- planDeVuelo))
}

function mkPlanesDestino() {
    return([
        mkPlanDestino(crd(1,2), crd(3,3), [Norte, Norte, Este])
        ,mkPlanDestino(crd(3,4), crd(0,1), [Sur, Sur, Sur, Oeste, Oeste, Oeste]),
        mkPlanDestino(crd(0,0), crd(5,5), [Norte, Este, Norte, Este, Norte, Este, Norte, Este, Norte, Este])
    ])
}

function mkVuelo(id, origen, destino, estado, etapa) {
    return(Vuelo(numero <- id,
                 origen <- origen,
                 destino <- destino,
                 estado <- estado,
                 etapaEnPlanDeVuelo <- etapa))
}

function mkVuelos() {
    return([
        mkVuelo(1, crd(1,2), crd(3,3), listoParaDespegar(), 0)
        ,mkVuelo(2, crd(3,4), crd(0,1), listoParaDespegar(), 0),
        mkVuelo(3, crd(0,0), crd(5,5), listoParaDespegar(), 0)
    ])
}

function mkTorreDeControl() {
	return(TorreDeControl(vs <- mkVuelos(), ps <- mkPlanesDestino()))
}

program {	
        VaciarTablero()
	Radar(mkTorreDeControl())
}




